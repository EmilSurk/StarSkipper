<!DOCTYPE html>

<html>
<head>
    <title>TP1 - Ex2 - Solution</title>
    <style>
        body{
            margin: 0;
            height: 100%;
            overflow: hidden;
        }
    </style>
    <script>
        let canvas;    // Objet DOM correspondant au canvas
        let graphics;  // Contexte de graphique 2d pour dessiner sur la canvas

        // Variable pour la position des étoiles
        let constellations = [];

        // Propriétés de l'application
        // Propriétés de la ville
        const cityLength = 64;
        const buildingWidth = 0.1;
        let farBuildingsHeights = [];
        let middleBuildingsHeights = [];
        let closeBuildingsHeights = [];
        let farBuildingsPos = [];
        let middleBuildingsPos = [];
        let closeBuildingsPos = [];
        const close_build_color = "rgb(150, 150, 150)";
        const middle_building_color = "rgb(100, 100, 100)";
        const far_building_color = "rgb(75, 75, 75)";

        // Propriétés du vaisseau 
        let vesselPos = {x:0, y:0}
        const maxSpeed = -25;
        const minSpeed = -10;
        let speed = minSpeed; // pixels par milliseconde
        let acceleration = 0.1; // pixels par milliseconde par milliseconde

        let isSpacebarPressed = false;
        let triangleIncrement = 0;
        const maxIncrements = 8;
        const incrementSize = 16; // Changer cette valeur pour contrôler la taille de chaque incrément
        let triangleInterval;
        let buildingSpeedIncrement = 0;
        let farBuildingSpeed;
        let middleBuildingSpeed;
        let frontBuildingSpeed;

        // Générer des constellations
        function generate_constellations(){
            let dispersion = 0.1;

            for (let i = 0; i < 1/dispersion; i++) {
                for (let j = 0; j < 1/dispersion; j++){
                    let n_stars = Math.floor(1 + Math.random() * 7);
                    let cx = (i + 0.5) * dispersion + (Math.random()-0.5) * dispersion / 2
                    let cy = (j + 0.5) * dispersion + (Math.random()-0.5) * dispersion / 2

                    let stars = [];

                    for (let k = 0; k < n_stars; k++) {
                        let pos = {x: cx + dispersion * (Math.random() - 0.5), y: cy + dispersion * (Math.random() - 0.5)}
                        stars.push(pos)
                    }
                    constellations.push(stars)
                }
            }
        }

        // Générer la ville
        function generate_city() {
            for(let i = 0; i < cityLength; i++) {
                // Les bâtiments les plus éloignés sont les plus grands
                farBuildingsHeights.push(Math.random() * canvas.height/2 + canvas.height/3);
                // Les bâtiments de distance moyenne sont de taille moyenne
                middleBuildingsHeights.push(Math.random() * canvas.height/3 + canvas.height/5);
                // Les bâtiments les plus proches sont les plus petits
                closeBuildingsHeights.push(Math.random() * canvas.height/4 + canvas.height/8);

                farBuildingsPos.push(i * buildingWidth);
                middleBuildingsPos.push(i * buildingWidth);
                closeBuildingsPos.push(i * buildingWidth);
            }
        }

        // Dessiner le smog
        function draw_smog() {
            const gradient = graphics.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "rgba(100, 81, 81, 0.5)"); // Smog violet clair au milieu
            gradient.addColorStop(1, "rgba(255, 209, 220, 0.20)");   // Transparent en bas

            graphics.fillStyle = gradient;
            graphics.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Fonction principale de dessin
        function draw() {
            graphics.clearRect(0, 0, canvas.width, canvas.height);
            draw_background();
            draw_city();
            draw_vessel();
            draw_smog();
        }

        // Dessiner le vaisseau
        function draw_vessel() {
            graphics.shadowBlur = 20;
            graphics.shadowColor = "blue";

            let vesselX = canvas.width / 2 + vesselPos.x;
            let vesselY = canvas.height / 2 + vesselPos.y;

            let incrementAmount = triangleIncrement * incrementSize;

            graphics.fillStyle = "turquoise";
            graphics.beginPath();
            graphics.moveTo(vesselX, vesselY - 15);
            graphics.lineTo(vesselX, vesselY + 15);
            graphics.lineTo(vesselX - 20 - incrementAmount, vesselY);
            graphics.closePath();
            graphics.fill();

            graphics.shadowBlur = 0;

            graphics.fillStyle = 'rgba(110, 95, 70, 1)';
            graphics.beginPath();
            graphics.moveTo(vesselX, vesselY - 15);
            graphics.lineTo(vesselX, vesselY + 15);
            graphics.lineTo(vesselX + 70, vesselY + 15);
            graphics.closePath();
            graphics.fill();
        }

        // Dessiner le fond
        function draw_background() {
            graphics.fillStyle = "#ff99ff";
            graphics.fillRect(0, 0, canvas.width, canvas.height);

            for (const constellation of constellations) {
                let prevStar = null;
                for (const star of constellation) {
                    graphics.fillStyle = "brown";
                    graphics.beginPath();
                    graphics.arc(star.x * canvas.width, star.y * canvas.height, 2, 0, Math.PI * 2);
                    graphics.fill();

                    if (prevStar) {
                        graphics.strokeStyle = "brown";
                        graphics.lineWidth = 0.5;
                        graphics.beginPath();
                        graphics.setLineDash([2, 2]);
                        graphics.moveTo(prevStar.x * canvas.width, prevStar.y * canvas.height);
                        graphics.lineTo(star.x * canvas.width, star.y * canvas.height);
                        graphics.stroke();
                        graphics.setLineDash([]);
                    }
                    prevStar = star;
                }
            }
        }

        // Dessiner la ville
        function draw_city(){
            graphics.fillStyle = close_build_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(farBuildingsPos[i] * canvas.width, canvas.height - farBuildingsHeights[i], buildingWidth * canvas.width, farBuildingsHeights[i]);
            }

             graphics.fillStyle = middle_building_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(middleBuildingsPos[i] * canvas.width, canvas.height - middleBuildingsHeights[i], buildingWidth * canvas.width, middleBuildingsHeights[i]);
            }

            graphics.fillStyle = far_building_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(closeBuildingsPos[i] * canvas.width, canvas.height - closeBuildingsHeights[i], buildingWidth * canvas.width, closeBuildingsHeights[i]);
            }
        }

        // Mettre à jour la position du vaisseau
        function updateVesselPosition(e){
            if (e.keyCode === 87 || e.keyCode === 38) { // W ou Flèche vers le haut
                vesselPos.y -= 30;
            }
            
            if (e.keyCode === 83 || e.keyCode === 40) { // S ou Flèche vers le bas
                vesselPos.y += 30;
            }
            
            if (e.keyCode === 65 || e.keyCode === 37) { // A ou Flèche gauche
                vesselPos.x -= 30;
            }

            if (e.keyCode === 68 || e.keyCode === 39) { // D ou Flèche droite
                vesselPos.x += 30;
            }
            
            if (e.keyCode === 32) { // Barre d'espace
                isSpacebarPressed = true;
                clearInterval(triangleInterval);
                

                if (farBuildingSpeed > maxSpeed) {
                    buildingSpeedIncrement -= 0.0003;
                }
                if (middleBuildingSpeed > maxSpeed) {
                    buildingSpeedIncrement -= 0.0003;
                } 
                if (frontBuildingSpeed > maxSpeed) {
                    buildingSpeedIncrement -= 0.0003;
                }


                triangleInterval = setInterval(() => {
                    if (triangleIncrement < maxIncrements) {
                        triangleIncrement++;
                    } else {
                        clearInterval(triangleInterval);
                    }
                }, 100);
            }
        }

        // Relâcher la barre d'espace
        function releaseSpace(e){
            if (e.keyCode === 32) { // Barre d'espace
                isSpacebarPressed = false;
                buildingSpeedIncrement = 0;
                clearInterval(triangleInterval);
                triangleInterval = setInterval(() => {
                    if (triangleIncrement > 0) {
                        triangleIncrement--;
                    } else {
                        clearInterval(triangleInterval);
                    }
                }, 100);
            }
        }

        // Initialisation de l'application
        function init() {
            canvas = document.getElementById("theCanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            window.addEventListener("keydown", updateVesselPosition, true);
            window.addEventListener("keyup", releaseSpace, true);
            graphics = canvas.getContext("2d");

            generate_constellations();
            generate_city();
            requestAnimationFrame(update);
        }

        // Mettre à jour l'animation
        function update(){        
            farBuildingSpeed = speed * 0.2 * 0.0003 + buildingSpeedIncrement;
            middleBuildingSpeed = speed * 0.5 * 0.0003 + buildingSpeedIncrement;
            frontBuildingSpeed = speed * 0.8 * 0.0003 + buildingSpeedIncrement; 

            for (let i = 0; i < cityLength; i++) {
                farBuildingsPos[i] += (farBuildingSpeed);
                middleBuildingsPos[i] += (middleBuildingSpeed);
                closeBuildingsPos[i] += (frontBuildingSpeed);


                if (farBuildingsPos[i] < -buildingWidth) {
                    farBuildingsPos[i] += cityLength * buildingWidth;
                }
                if (middleBuildingsPos[i] < -buildingWidth) {
                    middleBuildingsPos[i] += cityLength * buildingWidth;
                }
                if (closeBuildingsPos[i] < -buildingWidth) {
                    closeBuildingsPos[i] += cityLength * buildingWidth;
                }
            }   
            draw();
            requestAnimationFrame(update);
        }
    </script>
</head>
<body onload="init()">
    <canvas id="theCanvas"></canvas>
</body>
</html>
