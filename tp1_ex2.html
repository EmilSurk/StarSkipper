<!DOCTYPE html>
<html>
<head>
    <title>TP1 - Ex2 - Solution</title>
    <style>
        body{
            margin: 0;
            height: 100%;
            overflow: hidden;
        }

    </style>
    <script>
        let canvas;    // Objet DOM correspondant au canvas
        let graphics;  // Contexte de graphique 2d pour dessiner sur la canvas

        // Variable pour la position des étoiles
        let constellations = [];

        /* Propriétés de l'application (Note: vous pouvez changer ces valeurs pour tester votre code) */
        // Propriétés de la ville
        const cityLength = 64;
        const buildingWidth = 0.1;
        let farBuildingsHeights = [];
        let middleBuildingsHeights = [];
        let closeBuildingsHeights = [];
        let farBuildingsPos = [];
        let middleBuildingsPos = [];
        let closeBuildingsPos = [];
        const close_build_color = "rgb(150, 150, 150)";
        const middle_building_color = "rgb(100, 100, 100)";
        const far_building_color = "rgb(75, 75, 75)";

        // Propriétés du vaisseau 
        let vesselPos = {x:0, y:0}
        const maxSpeed = -25;
        const minSpeed = -10;
        let speed = minSpeed; // pixels per millisecond
        let acceleration = 0.1; // pixels per millisecond per millisecond


        function generate_constellations(){
            // Génération des constellations
            let dispersion = 0.1;

            for (let i = 0; i < 1/dispersion; i++) {
                for (let j = 0; j < 1/dispersion; j++){
                    let n_stars = Math.floor(1 + Math.random() * 7);
                    let cx = (i + 0.5) * dispersion + (Math.random()-0.5) * dispersion / 2
                    let cy = (j + 0.5) * dispersion + (Math.random()-0.5) * dispersion / 2

                    let stars = [];

                    for (let k = 0; k < n_stars; k++) {
                        let pos = {x: cx + dispersion * (Math.random() - 0.5), y: cy + dispersion * (Math.random() - 0.5)}
                        stars.push(pos)
                    }
                    constellations.push(stars)
                }
            }
        }

        function generate_city() {
            for(let i = 0; i < cityLength; i++) {
                // Les bâtiments les plus éloignés sont les plus grands
                farBuildingsHeights.push(Math.random() * canvas.height/2 + canvas.height/3);
                // Les bâtiments de distance moyenne sont de taille moyenne
                middleBuildingsHeights.push(Math.random() * canvas.height/3 + canvas.height/5);
                // Les bâtiments les plus proches sont les plus petits
                closeBuildingsHeights.push(Math.random() * canvas.height/4 + canvas.height/8);

                farBuildingsPos.push(i * buildingWidth);
                middleBuildingsPos.push(i * buildingWidth);
                closeBuildingsPos.push(i * buildingWidth);
            }
        }

        function draw_smog() {
            // Dégradé de smog vertical
            const gradient = graphics.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "rgba(0, 0, 0, 0.7)"); // Couleur sombre en haut
            gradient.addColorStop(1, "rgba(0, 0, 0, 0)");   // Transparent en bas

            // Appliquer le dégradé au rectangle plein écran
            graphics.fillStyle = gradient;
            graphics.fillRect(0, 0, canvas.width, canvas.height);
        }

        function draw() {
            // On nettoie le canvas avant de redessiner
            graphics.clearRect(0, 0, canvas.width, canvas.height);

            // Dessine le background
            draw_background();

            // On dessine la ville
            draw_city();

            // On dessine le vaisseau
            draw_vessel();

            // Draw smog
            draw_smog();
        }

        function draw_vessel() {
            // Dessiner le vaisseau constitué de deux triangles orientés horizontalement et pointant vers l'extérieur

            // Dessiner la propulsion bleue floue du vaisseau
            graphics.shadowBlur = 20;
            graphics.shadowColor = "blue";

            // Adjust the triangles according to vesselPos values
            let vesselX = canvas.width / 2 + vesselPos.x;
            let vesselY = canvas.height / 2 + vesselPos.y;

            // Triangle gauche (turquoise) pointant vers la gauche
            graphics.fillStyle = "turquoise";
            graphics.beginPath();
            graphics.moveTo(vesselX, vesselY - 15);  // Point du haut
            graphics.lineTo(vesselX, vesselY + 15);  // Point du bas
            graphics.lineTo(vesselX - 60, vesselY);  // Sommet gauche
            graphics.closePath();
            graphics.fill();

            graphics.shadowBlur = 0;  // Réinitialiser le flou pour les autres dessins

            // Triangle droit (brun clair) pointant vers la droite
            graphics.fillStyle = "#c68c53";
            graphics.beginPath();
            graphics.moveTo(vesselX, vesselY - 15);  // Point du haut
            graphics.lineTo(vesselX, vesselY + 15);  // Point du bas
            graphics.lineTo(vesselX + 70, vesselY + 15);  // Sommet droit
            graphics.closePath();
            graphics.fill();
        }





        function draw_background(){
            // Couleur de fond sombre
            graphics.fillStyle = "#ff99ff";
            graphics.fillRect(0, 0, canvas.width, canvas.height);

            // Dessiner les étoiles et les constellations
            graphics.fillStyle = "white";
            graphics.strokeStyle = "white";
            graphics.lineWidth = 2;

            for (const constellation of constellations) {
                for (const star of constellation) {
                    // Dessiner une étoile sous forme de cercle
                    graphics.beginPath();
                    graphics.arc(star.x * canvas.width, star.y * canvas.height, 3, 0, Math.PI * 2);
                    graphics.fill();

                    // Dessiner des lignes pointillées pour les constellations
                    for (const otherStar of constellation) {
                        graphics.beginPath();
                        graphics.moveTo(star.x * canvas.width, star.y * canvas.height);
                        graphics.lineTo(otherStar.x * canvas.width, otherStar.y * canvas.height);
                        graphics.stroke();
                    }
                }
            }
        }

        function draw_city(){
            // Dessiner les bâtiments lointains
            graphics.fillStyle = close_build_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(farBuildingsPos[i] * canvas.width, canvas.height - farBuildingsHeights[i], buildingWidth * canvas.width, farBuildingsHeights[i]);
            }

            // Dessiner les bâtiments moyens
            graphics.fillStyle = middle_building_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(middleBuildingsPos[i] * canvas.width, canvas.height - middleBuildingsHeights[i], buildingWidth * canvas.width, middleBuildingsHeights[i]);
            }

            // Dessiner les bâtiments proches
            graphics.fillStyle = far_building_color;
            for(let i = 0; i < cityLength; i++) {
                graphics.fillRect(closeBuildingsPos[i] * canvas.width, canvas.height - closeBuildingsHeights[i], buildingWidth * canvas.width, closeBuildingsHeights[i]);
            }
        }

        function updateVesselPosition(e){

            // For vertical movement (up and down)
            if (e.keyCode === 87 || e.keyCode === 38) { // W or Up Arrow
                vesselPos.y -= 10;
            }
            
            if (e.keyCode === 83 || e.keyCode === 40) { // S or Down Arrow
                vesselPos.y += 10;
            }

            
            if (e.keyCode === 65 || e.keyCode === 37) { // A or Left Arrow
                vesselPos.x -= 10;
            }

            if (e.keyCode === 68 || e.keyCode === 39) { // D or Right Arrow
                vesselPos.x += 10;
            }
        
                    // Check if the space bar is pressed for boost acceleration
            if (e.keyCode === 32) { // Spacebar
                speed += acceleration; 
            }
        }

        function releaseSpace(e){
            // Touche Espace
            if (e.keyCode === 32) { // Spacebar
                // Reset the speed when the Spacebar is released
                speed = Math.min(speed + acceleration, maxSpeed);
            }
        }

        function init() {
            // Initialisation du dessin. Il s'affiche sur toute la fenêtre
            canvas = document.getElementById("theCanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            window.addEventListener("keydown", updateVesselPosition, true);
            window.addEventListener("keyup", releaseSpace, true);
            graphics = canvas.getContext("2d");

            
            // Initialisation
            generate_constellations();
            generate_city();
            requestAnimationFrame(update);
        }

        function update(){
            // Update the position of the buildings based on the vessel's speed
            for (let i = 0; i < cityLength; i++) {
                farBuildingsPos[i] += speed * 0.0002;
                middleBuildingsPos[i] += (speed * 0.5) * 0.0002;
                closeBuildingsPos[i] += (speed * 0.9) * 0.0002;
                
                // If a building is out of the canvas, reposition it to the right
                if (farBuildingsPos[i] < -buildingWidth) {
                    farBuildingsPos[i] += cityLength * buildingWidth;
                }
                if (middleBuildingsPos[i] < -buildingWidth) {
                    middleBuildingsPos[i] += cityLength * buildingWidth;
                }
                if (closeBuildingsPos[i] < -buildingWidth) {
                    closeBuildingsPos[i] += cityLength * buildingWidth;
                }
            }
            draw()

            // Request new animation frame
            requestAnimationFrame(update);
}

    </script>
</head>
<body onload="init()">
<canvas id="theCanvas"></canvas>
</body>
</html>